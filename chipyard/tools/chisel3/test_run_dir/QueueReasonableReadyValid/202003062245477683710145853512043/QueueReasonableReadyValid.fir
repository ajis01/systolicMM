;buildInfoPackage: chisel3, version: 3.2.0, scalaVersion: 2.12.10, sbtVersion: 1.2.8
circuit QueueReasonableReadyValid : 
  module Queue : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}, count : UInt<3>}
    
    cmem _T : UInt<4>[4] @[Decoupled.scala 209:24]
    reg value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 29:33]
    reg value_1 : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 29:33]
    reg _T_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 212:35]
    node _T_2 = eq(value, value_1) @[Decoupled.scala 214:41]
    node _T_3 = eq(_T_1, UInt<1>("h00")) @[Decoupled.scala 215:36]
    node _T_4 = and(_T_2, _T_3) @[Decoupled.scala 215:33]
    node _T_5 = and(_T_2, _T_1) @[Decoupled.scala 216:32]
    node _T_6 = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire _T_7 : UInt<1>
    _T_7 <= _T_6
    node _T_8 = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire _T_9 : UInt<1>
    _T_9 <= _T_8
    when _T_7 : @[Decoupled.scala 220:17]
      infer mport _T_10 = _T[value], clock @[Decoupled.scala 221:8]
      _T_10 <= io.enq.bits @[Decoupled.scala 221:24]
      node wrap = eq(value, UInt<2>("h03")) @[Counter.scala 37:24]
      node _T_11 = add(value, UInt<1>("h01")) @[Counter.scala 38:22]
      node _T_12 = tail(_T_11, 1) @[Counter.scala 38:22]
      value <= _T_12 @[Counter.scala 38:13]
      skip @[Decoupled.scala 220:17]
    when _T_9 : @[Decoupled.scala 224:17]
      node wrap_1 = eq(value_1, UInt<2>("h03")) @[Counter.scala 37:24]
      node _T_13 = add(value_1, UInt<1>("h01")) @[Counter.scala 38:22]
      node _T_14 = tail(_T_13, 1) @[Counter.scala 38:22]
      value_1 <= _T_14 @[Counter.scala 38:13]
      skip @[Decoupled.scala 224:17]
    node _T_15 = neq(_T_7, _T_9) @[Decoupled.scala 227:16]
    when _T_15 : @[Decoupled.scala 227:28]
      _T_1 <= _T_7 @[Decoupled.scala 228:16]
      skip @[Decoupled.scala 227:28]
    node _T_16 = eq(_T_4, UInt<1>("h00")) @[Decoupled.scala 231:19]
    io.deq.valid <= _T_16 @[Decoupled.scala 231:16]
    node _T_17 = eq(_T_5, UInt<1>("h00")) @[Decoupled.scala 232:19]
    io.enq.ready <= _T_17 @[Decoupled.scala 232:16]
    infer mport _T_18 = _T[value_1], clock @[Decoupled.scala 233:21]
    io.deq.bits <= _T_18 @[Decoupled.scala 233:15]
    node _T_19 = sub(value, value_1) @[Decoupled.scala 248:40]
    node _T_20 = tail(_T_19, 1) @[Decoupled.scala 248:40]
    node _T_21 = and(_T_1, _T_2) @[Decoupled.scala 250:32]
    node _T_22 = mux(_T_21, UInt<3>("h04"), UInt<1>("h00")) @[Decoupled.scala 250:20]
    node _T_23 = or(_T_22, _T_20) @[Decoupled.scala 250:62]
    io.count <= _T_23 @[Decoupled.scala 250:14]
    
  module MaxPeriodFibonacciLFSR : 
    input clock : Clock
    input reset : Reset
    output io : {flip seed : {valid : UInt<1>, bits : UInt<1>[16]}, flip increment : UInt<1>, out : UInt<1>[16]}
    
    wire _T : UInt<1>[16] @[PRNG.scala 38:28]
    _T[0] <= UInt<1>("h01") @[PRNG.scala 38:28]
    _T[1] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[2] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[3] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[4] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[5] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[6] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[7] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[8] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[9] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[10] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[11] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[12] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[13] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[14] <= UInt<1>("h00") @[PRNG.scala 38:28]
    _T[15] <= UInt<1>("h00") @[PRNG.scala 38:28]
    reg state : UInt<1>[16], clock with : (reset => (reset, _T)) @[PRNG.scala 47:50]
    when io.increment : @[PRNG.scala 61:23]
      node _T_1 = xor(state[15], state[13]) @[LFSR.scala 15:41]
      node _T_2 = xor(_T_1, state[12]) @[LFSR.scala 15:41]
      node _T_3 = xor(_T_2, state[10]) @[LFSR.scala 15:41]
      state[0] <= _T_3 @[PRNG.scala 62:11]
      state[1] <= state[0] @[PRNG.scala 62:11]
      state[2] <= state[1] @[PRNG.scala 62:11]
      state[3] <= state[2] @[PRNG.scala 62:11]
      state[4] <= state[3] @[PRNG.scala 62:11]
      state[5] <= state[4] @[PRNG.scala 62:11]
      state[6] <= state[5] @[PRNG.scala 62:11]
      state[7] <= state[6] @[PRNG.scala 62:11]
      state[8] <= state[7] @[PRNG.scala 62:11]
      state[9] <= state[8] @[PRNG.scala 62:11]
      state[10] <= state[9] @[PRNG.scala 62:11]
      state[11] <= state[10] @[PRNG.scala 62:11]
      state[12] <= state[11] @[PRNG.scala 62:11]
      state[13] <= state[12] @[PRNG.scala 62:11]
      state[14] <= state[13] @[PRNG.scala 62:11]
      state[15] <= state[14] @[PRNG.scala 62:11]
      skip @[PRNG.scala 61:23]
    when io.seed.valid : @[PRNG.scala 65:25]
      state[0] <= io.seed.bits[0] @[PRNG.scala 66:11]
      state[1] <= io.seed.bits[1] @[PRNG.scala 66:11]
      state[2] <= io.seed.bits[2] @[PRNG.scala 66:11]
      state[3] <= io.seed.bits[3] @[PRNG.scala 66:11]
      state[4] <= io.seed.bits[4] @[PRNG.scala 66:11]
      state[5] <= io.seed.bits[5] @[PRNG.scala 66:11]
      state[6] <= io.seed.bits[6] @[PRNG.scala 66:11]
      state[7] <= io.seed.bits[7] @[PRNG.scala 66:11]
      state[8] <= io.seed.bits[8] @[PRNG.scala 66:11]
      state[9] <= io.seed.bits[9] @[PRNG.scala 66:11]
      state[10] <= io.seed.bits[10] @[PRNG.scala 66:11]
      state[11] <= io.seed.bits[11] @[PRNG.scala 66:11]
      state[12] <= io.seed.bits[12] @[PRNG.scala 66:11]
      state[13] <= io.seed.bits[13] @[PRNG.scala 66:11]
      state[14] <= io.seed.bits[14] @[PRNG.scala 66:11]
      state[15] <= io.seed.bits[15] @[PRNG.scala 66:11]
      skip @[PRNG.scala 65:25]
    io.out[0] <= state[0] @[PRNG.scala 69:10]
    io.out[1] <= state[1] @[PRNG.scala 69:10]
    io.out[2] <= state[2] @[PRNG.scala 69:10]
    io.out[3] <= state[3] @[PRNG.scala 69:10]
    io.out[4] <= state[4] @[PRNG.scala 69:10]
    io.out[5] <= state[5] @[PRNG.scala 69:10]
    io.out[6] <= state[6] @[PRNG.scala 69:10]
    io.out[7] <= state[7] @[PRNG.scala 69:10]
    io.out[8] <= state[8] @[PRNG.scala 69:10]
    io.out[9] <= state[9] @[PRNG.scala 69:10]
    io.out[10] <= state[10] @[PRNG.scala 69:10]
    io.out[11] <= state[11] @[PRNG.scala 69:10]
    io.out[12] <= state[12] @[PRNG.scala 69:10]
    io.out[13] <= state[13] @[PRNG.scala 69:10]
    io.out[14] <= state[14] @[PRNG.scala 69:10]
    io.out[15] <= state[15] @[PRNG.scala 69:10]
    
  module QueueReasonableReadyValid : 
    input clock : Clock
    input reset : UInt<1>
    output io : {}
    
    inst q of Queue @[QueueSpec.scala 38:17]
    q.clock <= clock
    q.reset <= reset
    wire elems : UInt<4>[20] @[QueueSpec.scala 39:22]
    elems[0] <= UInt<3>("h05") @[QueueSpec.scala 39:22]
    elems[1] <= UInt<2>("h03") @[QueueSpec.scala 39:22]
    elems[2] <= UInt<4>("h0c") @[QueueSpec.scala 39:22]
    elems[3] <= UInt<4>("h0b") @[QueueSpec.scala 39:22]
    elems[4] <= UInt<4>("h0b") @[QueueSpec.scala 39:22]
    elems[5] <= UInt<3>("h07") @[QueueSpec.scala 39:22]
    elems[6] <= UInt<2>("h03") @[QueueSpec.scala 39:22]
    elems[7] <= UInt<4>("h0a") @[QueueSpec.scala 39:22]
    elems[8] <= UInt<4>("h0b") @[QueueSpec.scala 39:22]
    elems[9] <= UInt<4>("h09") @[QueueSpec.scala 39:22]
    elems[10] <= UInt<1>("h01") @[QueueSpec.scala 39:22]
    elems[11] <= UInt<4>("h0e") @[QueueSpec.scala 39:22]
    elems[12] <= UInt<1>("h00") @[QueueSpec.scala 39:22]
    elems[13] <= UInt<4>("h08") @[QueueSpec.scala 39:22]
    elems[14] <= UInt<3>("h05") @[QueueSpec.scala 39:22]
    elems[15] <= UInt<3>("h06") @[QueueSpec.scala 39:22]
    elems[16] <= UInt<3>("h05") @[QueueSpec.scala 39:22]
    elems[17] <= UInt<1>("h01") @[QueueSpec.scala 39:22]
    elems[18] <= UInt<2>("h02") @[QueueSpec.scala 39:22]
    elems[19] <= UInt<4>("h0e") @[QueueSpec.scala 39:22]
    reg value : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[Counter.scala 29:33]
    reg value_1 : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[Counter.scala 29:33]
    node _T = lt(value, UInt<5>("h014")) @[QueueSpec.scala 45:34]
    q.io.enq.valid <= _T @[QueueSpec.scala 45:18]
    node _T_1 = eq(q.io.count, UInt<3>("h04")) @[QueueSpec.scala 47:39]
    node _T_2 = or(q.io.enq.ready, _T_1) @[QueueSpec.scala 47:25]
    node _T_3 = bits(reset, 0, 0) @[QueueSpec.scala 47:9]
    node _T_4 = or(_T_2, _T_3) @[QueueSpec.scala 47:9]
    node _T_5 = eq(_T_4, UInt<1>("h00")) @[QueueSpec.scala 47:9]
    when _T_5 : @[QueueSpec.scala 47:9]
      printf(clock, UInt<1>(1), "Assertion failed\n    at QueueSpec.scala:47 assert(q.io.enq.ready || q.io.count === queueDepth.U)\n") @[QueueSpec.scala 47:9]
      stop(clock, UInt<1>(1), 1) @[QueueSpec.scala 47:9]
      skip @[QueueSpec.scala 47:9]
    inst MaxPeriodFibonacciLFSR of MaxPeriodFibonacciLFSR @[PRNG.scala 82:22]
    MaxPeriodFibonacciLFSR.clock <= clock
    MaxPeriodFibonacciLFSR.reset <= reset
    MaxPeriodFibonacciLFSR.io.seed.valid <= UInt<1>("h00") @[PRNG.scala 83:24]
    MaxPeriodFibonacciLFSR.io.seed.bits[0] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[1] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[2] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[3] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[4] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[5] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[6] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[7] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[8] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[9] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[10] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[11] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[12] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[13] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[14] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.seed.bits[15] is invalid @[PRNG.scala 84:23]
    MaxPeriodFibonacciLFSR.io.increment <= UInt<1>("h01") @[PRNG.scala 85:23]
    node _T_6 = cat(MaxPeriodFibonacciLFSR.io.out[1], MaxPeriodFibonacciLFSR.io.out[0]) @[PRNG.scala 86:17]
    node _T_7 = cat(MaxPeriodFibonacciLFSR.io.out[3], MaxPeriodFibonacciLFSR.io.out[2]) @[PRNG.scala 86:17]
    node _T_8 = cat(_T_7, _T_6) @[PRNG.scala 86:17]
    node _T_9 = cat(MaxPeriodFibonacciLFSR.io.out[5], MaxPeriodFibonacciLFSR.io.out[4]) @[PRNG.scala 86:17]
    node _T_10 = cat(MaxPeriodFibonacciLFSR.io.out[7], MaxPeriodFibonacciLFSR.io.out[6]) @[PRNG.scala 86:17]
    node _T_11 = cat(_T_10, _T_9) @[PRNG.scala 86:17]
    node _T_12 = cat(_T_11, _T_8) @[PRNG.scala 86:17]
    node _T_13 = cat(MaxPeriodFibonacciLFSR.io.out[9], MaxPeriodFibonacciLFSR.io.out[8]) @[PRNG.scala 86:17]
    node _T_14 = cat(MaxPeriodFibonacciLFSR.io.out[11], MaxPeriodFibonacciLFSR.io.out[10]) @[PRNG.scala 86:17]
    node _T_15 = cat(_T_14, _T_13) @[PRNG.scala 86:17]
    node _T_16 = cat(MaxPeriodFibonacciLFSR.io.out[13], MaxPeriodFibonacciLFSR.io.out[12]) @[PRNG.scala 86:17]
    node _T_17 = cat(MaxPeriodFibonacciLFSR.io.out[15], MaxPeriodFibonacciLFSR.io.out[14]) @[PRNG.scala 86:17]
    node _T_18 = cat(_T_17, _T_16) @[PRNG.scala 86:17]
    node _T_19 = cat(_T_18, _T_15) @[PRNG.scala 86:17]
    node _T_20 = cat(_T_19, _T_12) @[PRNG.scala 86:17]
    node _T_21 = bits(_T_20, 4, 4) @[QueueSpec.scala 49:29]
    q.io.deq.ready <= _T_21 @[QueueSpec.scala 49:18]
    node _T_22 = eq(q.io.count, UInt<1>("h00")) @[QueueSpec.scala 51:39]
    node _T_23 = or(q.io.deq.valid, _T_22) @[QueueSpec.scala 51:25]
    node _T_24 = bits(reset, 0, 0) @[QueueSpec.scala 51:9]
    node _T_25 = or(_T_23, _T_24) @[QueueSpec.scala 51:9]
    node _T_26 = eq(_T_25, UInt<1>("h00")) @[QueueSpec.scala 51:9]
    when _T_26 : @[QueueSpec.scala 51:9]
      printf(clock, UInt<1>(1), "Assertion failed\n    at QueueSpec.scala:51 assert(q.io.deq.valid || q.io.count === 0.U)\n") @[QueueSpec.scala 51:9]
      stop(clock, UInt<1>(1), 1) @[QueueSpec.scala 51:9]
      skip @[QueueSpec.scala 51:9]
    q.io.enq.bits <= elems[value] @[QueueSpec.scala 53:17]
    node _T_27 = and(q.io.enq.ready, q.io.enq.valid) @[Decoupled.scala 40:37]
    when _T_27 : @[QueueSpec.scala 54:25]
      node _T_28 = eq(value, UInt<5>("h014")) @[Counter.scala 37:24]
      node _T_29 = add(value, UInt<1>("h01")) @[Counter.scala 38:22]
      node _T_30 = tail(_T_29, 1) @[Counter.scala 38:22]
      value <= _T_30 @[Counter.scala 38:13]
      when _T_28 : @[Counter.scala 40:21]
        value <= UInt<1>("h00") @[Counter.scala 40:29]
        skip @[Counter.scala 40:21]
      skip @[QueueSpec.scala 54:25]
    node _T_31 = and(q.io.deq.ready, q.io.deq.valid) @[Decoupled.scala 40:37]
    when _T_31 : @[QueueSpec.scala 57:25]
      node _T_32 = eq(value_1, UInt<5>("h014")) @[Counter.scala 37:24]
      node _T_33 = add(value_1, UInt<1>("h01")) @[Counter.scala 38:22]
      node _T_34 = tail(_T_33, 1) @[Counter.scala 38:22]
      value_1 <= _T_34 @[Counter.scala 38:13]
      when _T_32 : @[Counter.scala 40:21]
        value_1 <= UInt<1>("h00") @[Counter.scala 40:29]
        skip @[Counter.scala 40:21]
      skip @[QueueSpec.scala 57:25]
    node _T_35 = eq(value_1, UInt<5>("h014")) @[QueueSpec.scala 60:21]
    when _T_35 : @[QueueSpec.scala 60:44]
      node _T_36 = bits(reset, 0, 0) @[QueueSpec.scala 61:9]
      node _T_37 = eq(_T_36, UInt<1>("h00")) @[QueueSpec.scala 61:9]
      when _T_37 : @[QueueSpec.scala 61:9]
        stop(clock, UInt<1>(1), 0) @[QueueSpec.scala 61:9]
        skip @[QueueSpec.scala 61:9]
      skip @[QueueSpec.scala 60:44]
    
